/* Plugin structure generated by Schiavoni Pure Data external Generator */
#include "m_pd.h"
#include "g_canvas.h"
#include "m_imp.h"

#include <string.h>
#include <time.h>
#include <stdlib.h>

static t_class *connector_class;

t_glist * connector_find_parent(t_glist * glist);

typedef struct{
   t_gobj * object;
} t_slots;

typedef enum{
   CONNECTOR_CONNECT,
   CONNECTOR_DISCONNECT,
   CONNECTOR_CONNECT_SEQ,
   CONNECTOR_DISCONNECT_SEQ,
   CONNECTOR_CONNECT_RANDOM,
   CONNECTOR_DISCONNECT_RANDOM
} t_connector_mode;

typedef struct _connector{
   t_object x_obj;
   t_symbol *sp_name;
   t_glist *glist;
   t_canvas *x_canvas;
   t_gobj * objects[1024];
} t_connector;


/* ----------------------------------------------------
 set target canvas
 -----------------------------------------*/
void connector_set_target(t_connector *x, t_symbol * sp_name){
   x->sp_name = sp_name;
   if(strcmp(sp_name->s_name, "") == 0){
      t_canvas *canvas=(t_canvas*)glist_getcanvas(x->glist);
      x->x_canvas = canvas;
      return;
   }
   //It was empty. Now we need to find the parent
   if(strcmp(x->sp_name->s_name, "") != 0){
      t_glist * glist = connector_find_parent(x->x_canvas);
      t_canvas *canvas=(t_canvas*)glist_getcanvas(glist);
      x->x_canvas = canvas;
   }
}

/* ----------------------------------------------------
 Recursive search
 -----------------------------------------*/
t_glist * connector_recursive_search(t_connector *x, t_glist *c){
   t_gobj*obj = NULL;
   for(obj = c->gl_list; obj; obj = obj->g_next) {
      if(pd_class(&obj->g_pd) != canvas_class)
         continue;
      //if subpatchname is empty, don't go recursively
      connector_recursive_search(x, ((t_glist *)obj));
      //look for subpatch name
      t_binbuf *bz = binbuf_new();
      t_symbol *patchsym;
      binbuf_addbinbuf(bz, ((t_canvas *)obj)->gl_obj.ob_binbuf);
      patchsym = atom_getsymbolarg(1, binbuf_getnatom(bz), binbuf_getvec(bz));
      binbuf_free(bz);
      if(strcmp(x->sp_name->s_name, patchsym->s_name) == 0
         || strcmp(x->sp_name->s_name, "") == 0)
         return (t_canvas *)obj;
   }
   return NULL;
}

/* ----------------------------------------------------
 make list
 -----------------------------------------*/
int connector_make_list(t_connector *x, t_glist *c){

   int i = 0;
   t_gobj * src_obj = NULL;

   // For every source object
   for(src_obj = c->gl_list; src_obj; src_obj = src_obj->g_next){
      x->objects[i] = src_obj;
      i++;
   }
   return i;
}

/* ----------------------------------------------------
 connect / disconnect
 -----------------------------------------*/
void connector_connect(t_connector *x, t_glist *c, t_connector_mode mode, t_symbol * src_name, t_symbol * snk_name){

   t_gobj * src_obj = NULL;
   t_gobj * snk_obj = NULL;

   int src_obj_index, snk_obj_index;
   int n_inlets, n_outlets;
   int i, j, k, l;
   int object_count;

   object_count = connector_make_list(x, c);

   // For every source object
   for(k = 0 ; k < object_count ; k++){
      // check if object is target
      src_obj = x->objects[k];
      if(src_name != NULL && strcmp(class_getname(pd_class(&(src_obj)->g_pd)), src_name->s_name) != 0)
         continue;
      src_obj_index = canvas_getindex(c, src_obj);
      n_outlets = obj_noutlets((t_object *)src_obj);
      //for every object in subpatch (sink)
      for(l = 0 ; l < object_count ; l++){
         // check if objects are the same
         snk_obj = x->objects[l];
         if(k == l)
            continue;
         // check if object is target
         if(snk_name != NULL && strcmp(class_getname(pd_class(&(snk_obj)->g_pd)), snk_name->s_name) != 0)
            continue;
         n_inlets = obj_ninlets((t_object *)snk_obj);
         snk_obj_index = canvas_getindex(c, snk_obj);
         // for every object source outlet
         for(i = 0 ; i < n_outlets; i++){
            // for every inlet in sink object
            for(j = 0 ; j < n_inlets ; j++){
               // XOR - Or both are signals or both are not
               if(obj_issignaloutlet((t_object *) src_obj, i) ^ obj_issignalinlet((t_object *)snk_obj, j))
                  continue;
               if(mode == CONNECTOR_CONNECT
                     || mode == CONNECTOR_CONNECT_SEQ
                     || mode == CONNECTOR_CONNECT_RANDOM){
                  // check if they are connected
                  if(!canvas_isconnected(c, (t_text *) src_obj, i, (t_text *) snk_obj, j)){
                     int ran_value = random();
//                     post("CON %d %d %d,%d %d,%d ", ran_value, ran_value % object_count, k, i, l, j);
                     if(mode == CONNECTOR_CONNECT_RANDOM && ran_value % object_count != 0)
                        continue;
                     canvas_connect(c, src_obj_index, i, snk_obj_index, j);
/*                     obj_connect((t_object *) src_obj, i, (t_object *) snk_obj, j);*/
                     if(mode == CONNECTOR_CONNECT_SEQ
                           || mode == CONNECTOR_CONNECT_RANDOM){
                        return;
                     }
                  }
               }
               if(mode == CONNECTOR_DISCONNECT
                     || mode == CONNECTOR_DISCONNECT_SEQ
                     || mode == CONNECTOR_DISCONNECT_RANDOM){
                  // check if they are connected
                  if(canvas_isconnected(c, (t_text *) src_obj, i, (t_text *) snk_obj, j)){
                     int ran_value = random();
//                     post("DIS %d %d %d,%d %d,%d ", ran_value, ran_value % object_count, k, i, l, j);
                     if(mode == CONNECTOR_CONNECT_RANDOM && ran_value % object_count != 0)
                        continue;
                     canvas_disconnect(c, src_obj_index, i, snk_obj_index, j);
/*                     obj_disconnect((t_object *) src_obj, i, (t_object *) snk_obj, j);*/
                     if(mode == CONNECTOR_DISCONNECT_SEQ
                           || mode == CONNECTOR_DISCONNECT_RANDOM){
                        return;
                     }
                  }
               }
            }
         }
      }
   }
   return;
}

/* ----------------------------------------------------
 connect all objects
 -----------------------------------------*/
void connector_connect_all(t_connector *x){
  t_glist *c = connector_recursive_search(x, x->x_canvas);
   if(c == NULL){
      return;
   }
   connector_connect(x, c, CONNECTOR_CONNECT, NULL, NULL);
}

/* ----------------------------------------------------
 disconnect all objects
 -----------------------------------------*/
void connector_disconnect_all(t_connector *x){
  t_glist *c = connector_recursive_search(x, x->x_canvas);
   if(c == NULL){
      return;
   }
   connector_connect(x, c, CONNECTOR_DISCONNECT, NULL, NULL);
}

/* ----------------------------------------------------
 connect sequence
 -----------------------------------------*/
void connector_connect_sequence(t_connector *x){
  t_glist *c = connector_recursive_search(x, x->x_canvas);
   if(c == NULL){
      return;
   }
   connector_connect(x, c, CONNECTOR_CONNECT_SEQ, NULL, NULL);
}

/* ----------------------------------------------------
 disconnect sequence
 -----------------------------------------*/
void connector_disconnect_sequence(t_connector *x){
  t_glist *c = connector_recursive_search(x, x->x_canvas);
   if(c == NULL){
      return;
   }
   connector_connect(x, c, CONNECTOR_DISCONNECT_SEQ, NULL, NULL);
}

/* ----------------------------------------------------
 connect random
 -----------------------------------------*/
void connector_connect_random(t_connector *x){
  t_glist *c = connector_recursive_search(x, x->x_canvas);
   if(c == NULL){
      return;
   }
   connector_connect(x, c, CONNECTOR_CONNECT_RANDOM, NULL, NULL);
}

/* ----------------------------------------------------
 disconnect random
 -----------------------------------------*/
void connector_disconnect_random(t_connector *x){
  t_glist *c = connector_recursive_search(x, x->x_canvas);
   if(c == NULL){
      return;
   }
   connector_connect(x, c, CONNECTOR_DISCONNECT_RANDOM, NULL, NULL);
}


/* ----------------------------------------------------
 connect objects
 -----------------------------------------*/
void connector_connect_obj(t_connector *x, t_symbol * src_name, t_symbol * snk_name){
  t_glist *c = connector_recursive_search(x, x->x_canvas);
   if(c == NULL){
      return;
   }
   connector_connect(x, c, CONNECTOR_CONNECT, src_name, snk_name);
}


/* ----------------------------------------------------
 disconnect objects
 -----------------------------------------*/
void connector_disconnect_obj(t_connector *x, t_symbol * src_name, t_symbol * snk_name){
  t_glist *c = connector_recursive_search(x, x->x_canvas);
   if(c == NULL){
      return;
   }
   connector_connect(x, c, CONNECTOR_DISCONNECT, src_name, snk_name);
}

/* ----------------------------------------------------
   Find parent
 -----------------------------------------*/
t_glist * connector_find_parent(t_glist * glist){
   while(glist->gl_owner){
      glist = glist->gl_owner;
   }
   return glist;
}

/* ----------------------------------------------------
 Constructor of the class
 -----------------------------------------*/
void * connector_new(t_symbol *sp_name_arg) {
   t_connector *x = (t_connector *) pd_new(connector_class);
   t_glist *glist=(t_glist *)canvas_getcurrent();
   x->glist = glist;
   x->sp_name = sp_name_arg;
   // if no name, we use the actual canvas
   if(strcmp(x->sp_name->s_name, "") != 0)
      glist = connector_find_parent(glist);
   t_canvas *canvas=(t_canvas*)glist_getcanvas(glist);
   x->x_canvas = canvas;
   srandom(time(0));
   return (void *) x;
}

/* ----------------------------------------------------
   Destroy the class
 -----------------------------------------*/
void connector_destroy(t_connector *x) {
   (void) x;
}

/* ----------------------------------------------------
   Setup
 -----------------------------------------*/
void connector_setup(void) {
   connector_class = class_new(gensym("connector"),
      (t_newmethod) connector_new, // Constructor
      (t_method) connector_destroy, // Destructor
      sizeof (t_connector),
      CLASS_DEFAULT,
      A_DEFSYMBOL,
      0);//Must always ends with a zero

   class_addmethod(connector_class, (t_method) connector_connect_all, gensym("connectall"), 0);
   class_addmethod(connector_class, (t_method) connector_disconnect_all, gensym("disconnectall"), 0);

   class_addmethod(connector_class, (t_method) connector_connect_sequence, gensym("connsequence"), 0);
   class_addmethod(connector_class, (t_method) connector_disconnect_sequence, gensym("disconnsequence"), 0);

   class_addmethod(connector_class, (t_method) connector_connect_random, gensym("connrandom"), 0);
   class_addmethod(connector_class, (t_method) connector_disconnect_random, gensym("disconnrandom"), 0);

   class_addmethod(connector_class, (t_method) connector_connect_obj, gensym("connect"), A_DEFSYMBOL, A_DEFSYMBOL,0);
   class_addmethod(connector_class, (t_method) connector_disconnect_obj, gensym("disconnect"), A_DEFSYMBOL, A_DEFSYMBOL, 0);

}
